# SCP - Container Documentation (Level 2)

This document provides a deep technical analysis of the **Level 2 Container Diagram**, detailing the infrastructure, security layers, and data orchestration of the Smart Community Platform.

---

## 1. Access & Edge Infrastructure

### 1.1 Ingress Layer (Nginx)
*   **Infrastructure**: High-availability Nginx cluster acting as the reverse proxy and edge gateway.
*   **Security Responsibilities**:
    *   **SSL/TLS Termination**: Enforces TLS 1.3 for all external traffic.
    *   **Rate Limiting**: Protects backend services from DDoS and rapid-fire API scraping.
    *   **Whitelist/Blacklist**: Geographic IP filtering to align with sovereign data border requirements.

### 1.2 User Interfaces
*   **Web Portal (React)**:
    *   **Scope**: Management, Oversight, and Administration.
    *   **Security**: Implements Content Security Policy (CSP) and secure cookie handling. Runs in modern browsers with no local PII caching.
*   **Mobile App (Flutter)**:
    *   **Scope**: Ground-level data collection for Field Agents.
    *   **Security**: Encrypted local storage (SQLite/Hive) for offline records. Biometric app-lock mandatory. Uses certificate pinning for API communication.

---

## 2. Security & Identity Layer

### 2.1 Identity Provider (Keycloak)
*   **Function**: The platform's "Single Source of Truth" for authentication (AuthN).
*   **Technical Role**:
    *   **OIDC Protocol**: Issues JWT tokens containing user roles and scope claims.
    *   **MFA Support**: Supports TOTP/SMS multi-factor authentication for administrative roles.
    *   **Federation**: Capable of federating with existing National ID systems (OpenID Connect / SAML).

---

## 3. The Backend Engine

### 3.1 SCP Modular Monolith (.NET Core)
*   **Architecture**: Logic is organized into decoupled modules (Identity, Finance, Workflows) but deployed as a single, performant unit.
*   **Internal Governance**:
    *   **Policy Engine**: Evaluates "Deny-Wins" logic before every database query.
    *   **Tenant Filter**: Injects `TenantID` context into every ORM transaction automatically.
    *   **Audit Middleware**: Intercepts all `POST/PUT/DELETE` requests to ensure they are logged before persistence.

---

## 4. Data Persistence Strategy

| Container | Technology | Operational Detail |
| :--- | :--- | :--- |
| **Primary DB** | PostgreSQL | Uses **Row-Level Security (RLS)** or mandatory discriminators to ensure tenant data never bleeds. Stores core state (Registries, Cases, Rules). |
| **Read Replica** | PostgreSQL | Replicated via streaming. Used for BI tools and the **Analytics & Data Mesh** dashboard, ensuring heavy reporting doesn't slow down field operations. |
| **Cache** | Redis | Clusters for cluster-wide session state, shared policy evaluations (PDP cache), and API throttling counters. |
| **Object Store** | S3 / MinIO | Stores unstructured data: Profile photos, biometric files (encrypted), and scanned PDF annexures. Access is via signed URLs generated by the Monolith. |

---

## 5. End-to-End Authentication & Authorization Flow

1.  **Request Initiation**: A field agent opens the Mobile App and authenticates against **Keycloak**.
2.  **Token Issuance**: Keycloak returns a **JWT** signed with the system's private key. The token includes a list of permissions (e.g., `person.create`) and limits (e.g., `geo.district:Gampaha`).
3.  **API Access**: The app sends the JWT in the `Authorization` header to the **Ingress**.
4.  **Monolith Validation**:
    *   Verifies the token signature.
    *   Checks the `GeoNodeID` claim against the requested resource.
    *   Verifies the `TenantID`.
5.  **Execution**: If all checks pass, the **Monolith** performs the requested operation and records an **Audit Event**.
